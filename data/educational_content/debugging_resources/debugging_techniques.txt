# Systematic Debugging Techniques

## The Scientific Method for Debugging

Debugging is like being a detective. You need to gather evidence, form hypotheses, and test them systematically. The most effective debuggers follow a structured approach rather than making random changes.

### The Universal Debugging Process

**1. Reproduce the Problem**
- Can you make the error happen again consistently?
- What specific inputs or actions trigger the problem?
- Does it happen every time or only sometimes?
- Document the exact steps to reproduce the issue

**2. Understand What Should Happen**
- What is the expected behavior?
- What output or result should you get?
- Are you testing with the right expectations?

**3. Observe What Actually Happens**
- What is the actual behavior?
- Where exactly does it differ from expectations?
- Are there error messages or unexpected outputs?

**4. Form Hypotheses**
- What could be causing this specific behavior?
- List multiple possible causes
- Start with the most likely causes

**5. Test Hypotheses Systematically**
- Test one hypothesis at a time
- Make small, targeted changes
- Observe the results of each change
- Keep track of what you've tried

### Debugging Techniques by Problem Type

**Print Statement Debugging (Most Fundamental)**

Strategic Print Placement:
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    print(f"Starting search for {target} in array of length {len(arr)}")
    
    while left <= right:
        mid = (left + right) // 2
        print(f"Checking index {mid}, value {arr[mid]}, target {target}")
        
        if arr[mid] == target:
            print(f"Found target at index {mid}")
            return mid
        elif arr[mid] < target:
            left = mid + 1
            print(f"Target is larger, new left bound: {left}")
        else:
            right = mid - 1
            print(f"Target is smaller, new right bound: {right}")
    
    print("Target not found")
    return -1
```

What to Print:
- Variable values at key points
- Function entry and exit points
- Loop iteration counters and conditions
- Decision points (if/else branches taken)

**Rubber Duck Debugging**
Explain your code line by line to an inanimate object (or imaginary listener):
- Forces you to think through each step
- Often reveals assumptions that aren't correct
- Helps identify gaps in logic
- No judgment or interruption

**Binary Search Debugging**
When you have a large codebase and aren't sure where the problem is:

1. Comment out half the code
2. Run the program
3. If error still occurs, problem is in remaining half
4. If error disappears, problem is in commented half
5. Repeat process on the problematic half

**Minimal Reproduction**
Create the smallest possible program that demonstrates the problem:
- Start with your full program
- Remove code piece by piece
- Stop when removing code makes the problem disappear
- The last piece removed is likely involved in the bug

### Advanced Debugging Strategies

**Logging vs Print Statements**
For more complex programs, use logging:
```python
import logging
logging.basicConfig(level=logging.DEBUG)

def process_data(data):
    logging.debug(f"Processing {len(data)} items")
    for item in data:
        logging.debug(f"Processing item: {item}")
        # process item
        logging.debug(f"Item processed successfully")
```

Benefits:
- Can be turned on/off without changing code
- Different levels (DEBUG, INFO, WARNING, ERROR)
- Can be directed to files
- Timestamps automatically included

**Debugger Tools**
Using built-in debuggers:
- Set breakpoints at suspicious lines
- Step through code line by line
- Inspect variable values at each step
- See the call stack (how you got to this point)

**Testing Individual Components**
When dealing with complex functions:
```python
# Test each part separately
def complex_calculation(data):
    # Step 1: validate input
    validated_data = validate_input(data)
    print(f"After validation: {validated_data}")
    
    # Step 2: transform data
    transformed_data = transform_data(validated_data)
    print(f"After transformation: {transformed_data}")
    
    # Step 3: calculate result
    result = calculate_result(transformed_data)
    print(f"Final result: {result}")
    
    return result
```

### Common Debugging Mistakes to Avoid

**Making Multiple Changes at Once**
- Change one thing at a time
- Test after each change
- If problem is fixed, you know which change worked
- If problem gets worse, you know what to undo

**Assuming the Problem is Complex**
- Simple mistakes cause most bugs
- Check basic things first: typos, missing semicolons, off-by-one errors
- Look for the obvious before investigating complex scenarios

**Not Reading Error Messages Carefully**
- Error messages often tell you exactly what's wrong
- Pay attention to line numbers and file names
- Look up unfamiliar error types

**Debugging in Your Head**
- Don't trust your mental model of what the code is doing
- Use print statements or debugger to see actual values
- Your assumptions about variable values are often wrong

### Debugging Different Types of Problems

**Infinite Loops**
Symptoms: Program hangs, uses high CPU
Strategy:
1. Add print statement at start of loop body
2. Print loop counter or condition variables
3. Check that loop variables are being modified
4. Verify loop termination condition

**Wrong Output**
Strategy:
1. Start with simple, known inputs
2. Trace expected vs actual values step by step
3. Find first point where they diverge
4. Focus debugging efforts on that area

**Intermittent Bugs**
Strategy:
1. Try to find pattern in when it occurs
2. Add extensive logging to capture state when it happens
3. Consider timing, input variations, or resource issues
4. Test with different data sets

### Building Debugging Skills

**Practice Systematic Approach**
- Don't jump to conclusions
- Follow the debugging process even for "obvious" bugs
- Document what you tried and what worked

**Learn from Each Bug**
- What caused this bug?
- How could it have been prevented?
- What debugging technique was most effective?
- How can you catch similar bugs faster next time?

**Build Debugging Intuition**
- Certain patterns of bugs happen in certain contexts
- Experience teaches you where to look first
- But still verify your intuition with systematic testing

### When to Ask for Help

Ask for help when:
- You've spent significant time without progress
- You've tried systematic debugging approaches
- You can clearly explain what you've tried
- You have a minimal reproduction of the problem

Before asking:
- Document the problem clearly
- List what you've already tried
- Prepare to share relevant code
- Be specific about what's not working

Remember: Debugging is a skill that improves with practice. Every bug you fix makes you a better debugger.
