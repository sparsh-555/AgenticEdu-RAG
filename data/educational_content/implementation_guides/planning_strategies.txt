# Binary Search Algorithm Implementation Guide

## Planning and Strategy

Binary search is one of the most fundamental algorithms in computer science. Before implementing it, it's crucial to understand the strategy and plan your approach systematically.

### Understanding the Problem

Binary search allows you to find a target value in a sorted array by repeatedly dividing the search space in half. The key insight is that if the array is sorted, you can eliminate half of the remaining elements with each comparison.

### Pre-Implementation Planning

1. **Verify Prerequisites**: Ensure your array is sorted. Binary search only works on sorted data.

2. **Define the Invariant**: The target element (if it exists) is always within the current search bounds [left, right].

3. **Choose Your Approach**: 
   - Iterative implementation (generally preferred for simplicity)
   - Recursive implementation (more elegant but uses additional stack space)

### Algorithm Design Strategy

The binary search strategy follows these steps:

1. **Initialize Boundaries**: Set left boundary to 0 and right boundary to array length - 1
2. **Calculate Midpoint**: Find the middle index to check
3. **Compare and Decide**: Compare the middle element with the target
4. **Adjust Boundaries**: Narrow the search space based on the comparison
5. **Repeat Until Found**: Continue until target is found or search space is exhausted

### Implementation Considerations

**Boundary Management**: 
- Be careful with inclusive vs exclusive boundaries
- Common mistake: off-by-one errors in boundary calculations

**Midpoint Calculation**:
- Use `mid = left + (right - left) // 2` to avoid integer overflow
- Avoid `mid = (left + right) // 2` in languages with fixed integer sizes

**Loop Termination**:
- Decide on loop condition: `left <= right` or `left < right`
- Ensure the loop will eventually terminate

### Step-by-Step Implementation Plan

1. **Define Function Signature**: 
   - Parameters: array, target value
   - Return: index of target or -1 if not found

2. **Initialize Variables**:
   - Set left and right boundaries
   - Prepare return variable

3. **Implement Main Loop**:
   - Calculate midpoint
   - Compare with target
   - Update boundaries

4. **Handle Edge Cases**:
   - Empty array
   - Single element array
   - Target not in array

### Best Practices

- **Clear Variable Names**: Use `left`, `right`, `mid` rather than `l`, `r`, `m`
- **Consistent Boundary Logic**: Stick to either inclusive or exclusive boundaries throughout
- **Comment Your Invariants**: Document what your loop maintains as true
- **Test Edge Cases**: Always test with empty arrays, single elements, and targets not in the array

### Time and Space Complexity

- **Time Complexity**: O(log n) - we eliminate half the search space each iteration
- **Space Complexity**: 
  - Iterative: O(1) - constant extra space
  - Recursive: O(log n) - due to call stack

This logarithmic time complexity makes binary search extremely efficient even for very large datasets, growing slowly as the input size increases.
